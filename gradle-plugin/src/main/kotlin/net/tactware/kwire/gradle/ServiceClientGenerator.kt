package net.tactware.kwire.gradle


import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeName
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asTypeName

class ServiceClientGenerator {

    fun generate(service: ServiceInfo): String {
        val pkg = service.packageName
        val iface = ClassName(pkg, service.interfaceName)
        val clientClassName = ClassName(pkg, "${service.interfaceName}Client")

        val file = FileSpec.builder(pkg, "${service.interfaceName}Client")
            .addFileComment("Generated by KWire RPC Plugin â€” DO NOT EDIT")
            // Core RPC types
            .addImport("net.tactware.kwire.core.messages", "RpcRequest", "RpcResponse", "StreamStart", "StreamData", "StreamEnd")
            .addImport("net.tactware.kwire.core", "RpcTransport")
            // JSON & time
            .addImport("kotlinx.datetime", "Clock")
            // Coroutines / Flow helpers
            .addImport("kotlinx.coroutines", "withTimeout", "CoroutineScope", "Dispatchers", "SupervisorJob", "launch")
            .addImport("kotlinx.coroutines.flow", "Flow", "MutableSharedFlow", "filterIsInstance", "first")
            // atomic delegate for stream ids (matches your example)
            .addImport("kotlinx.atomicfu", "atomic")
            .addType(buildClientClass(service, iface, clientClassName))
            .addFunction(buildFactoryFunction(iface, clientClassName))
            .build()

        return file.toString()
    }

    private fun buildClientClass(
        service: ServiceInfo,
        iface: ClassName,
        clientClassName: ClassName,
    ): TypeSpec {
        val ctor = FunSpec.constructorBuilder()
            .addParameter("transport", ClassName("net.tactware.kwire.core", "RpcTransport"))
            .addParameter(
                ParameterSpec.builder("json", ClassName("kotlinx.serialization.json", "Json"))
                    .defaultValue("defaultJson()")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("callTimeoutMs", Long::class)
                    .defaultValue("5_000L")
                    .build()
            )
            .build()

        val cls = TypeSpec.classBuilder(clientClassName)
            .addKdoc("Client implementation for %L (%L)", service.interfaceName, service.serviceName)
            .addSuperinterface(iface)
            .primaryConstructor(ctor)
            .addProperty(PropertySpec.builder("transport", ClassName("net.tactware.kwire.core", "RpcTransport")).initializer("transport").addModifiers(KModifier.PRIVATE).build())
            .addProperty(PropertySpec.builder("json", ClassName("kotlinx.serialization.json", "Json")).initializer("json").addModifiers(KModifier.PRIVATE).build())
            .addProperty(PropertySpec.builder("callTimeoutMs", Long::class).initializer("callTimeoutMs").addModifiers(KModifier.PRIVATE).build())
            // a private coroutine scope for streaming plumbing
            .addProperty(
                PropertySpec.builder("scope", ClassName("kotlinx.coroutines", "CoroutineScope"))
                    .initializer("CoroutineScope(SupervisorJob() + Dispatchers.Default)")
                    .addModifiers(KModifier.PRIVATE)
                    .build()
            )
            .addFunction(genMessageIdFn())
            .addFunction(genStreamIdFn())
            // Backing flows + atomic ids for NO-ARG streaming methods
            .apply {
                service.methods.filter { it.isStreaming && it.parameters.isEmpty() }.forEach { m ->
                    val itemType = flowInnerType(m.returnType) // e.g., List<com.pkg.User>
                    val base = methodBase(m.methodName)
                    addProperty(
                        PropertySpec.builder(
                            "_${m.methodName}",
                            ClassName("kotlinx.coroutines.flow", "MutableSharedFlow")
                                .parameterizedBy(itemType.asTypeNameFromString())
                        )
                            .initializer("MutableSharedFlow()")
                            .addModifiers(KModifier.PRIVATE)
                            .build()
                    )
                    addProperty(
                        PropertySpec.builder("stream${base}Id", String::class.asTypeName().copy(nullable = true))
                            .mutable(true)
                            .delegate(CodeBlock.of("atomic<String?>(null)"))
                            .addModifiers(KModifier.PRIVATE)
                            .build()
                    )
                }
            }
            // Methods
            .apply {
                service.methods.forEach { m -> addFunction(generateMethodImpl(service, m)) }
            }
            // Init block to start/stop streams on subscription changes (no-arg only)
            .addInitializerBlock(initStreamingBlock(service))
            .addType(TypeSpec.companionObjectBuilder().addFunction(defaultJsonFun()).build())
            .build()

        return cls
    }

    private fun buildFactoryFunction(
        iface: ClassName,
        clientClassName: ClassName,
    ): FunSpec =
        FunSpec.builder("create${iface.simpleName}Client")
            .returns(iface)
            .addParameter("transport", ClassName("net.tactware.kwire.core", "RpcTransport"))
            .addParameter(
                ParameterSpec.builder("json", ClassName("kotlinx.serialization.json", "Json").copy(nullable = true))
                    .defaultValue("null")
                    .build()
            )
            .addParameter(ParameterSpec.builder("callTimeoutMs", Long::class).defaultValue("5_000L").build())
            .addCode(
                CodeBlock.of(
                    """
                    val actualJson = json ?: ${clientClassName}.defaultJson()
                    return %T(transport, actualJson, callTimeoutMs)
                    """.trimIndent(),
                    clientClassName
                )
            )
            .build()

    private fun generateMethodImpl(service: ServiceInfo, m: MethodInfo): FunSpec {
        val hasParams = m.parameters.isNotEmpty()

        return if (m.isStreaming) {
            if (!hasParams) {
                // No-arg streaming: return the backing flow
                FunSpec.builder(m.methodName)
                    .addModifiers(KModifier.OVERRIDE)
                    .returns(m.returnType.asTypeNameFromString())
                    .addCode("return _%L\n", m.methodName)
                    .build()
            } else {
                // Parameterized streaming: callbackFlow fallback (stream id per call)
                val varName = "stream${methodBase(m.methodName)}Id"
                FunSpec.builder(m.methodName)
                    .addModifiers(KModifier.OVERRIDE)
                    .returns(m.returnType.asTypeNameFromString())
                    .apply {
                        if (hasParams) addParameters(m.parameters.map { ParameterSpec.builder(it.name, it.type.asTypeNameFromString()).build() })
                    }
                    .addCode(
                        """
                        return callbackFlow {
                            val $varName = generateStreamId()
                            val start = StreamStart(
                                messageId = generateMessageId(),
                                timestamp = Clock.System.now().toEpochMilliseconds(),
                                streamId = $varName,
                                serviceName = %S,
                                methodId = %S,
                                parameters = listOf(${paramsEncode(m)})
                            )
                            transport.send(start)

                            val job = kotlinx.coroutines.GlobalScope.launch {
                                transport.receive().filterIsInstance<StreamData>().collect { ev ->
                                    if (ev.streamId == $varName) {
                                        val value = json.decodeFromString<%L>(ev.data.toString())
                                        trySend(value)
                                    }
                                }
                            }

                            awaitClose {
                                job.cancel()
                                transport.send(
                                    StreamEnd(
                                        messageId = generateMessageId(),
                                        timestamp = Clock.System.now().toEpochMilliseconds(),
                                        streamId = $varName
                                    )
                                )
                            }
                        }
                        """.trimIndent(),
                        service.serviceName,
                        m.rpcMethodId,
                        flowInnerType(m.returnType)
                    )
                    .build()
            }
        } else {
            // Unary (suspend) call
            FunSpec.builder(m.methodName)
                .addModifiers(KModifier.OVERRIDE, KModifier.SUSPEND)
                .returns(m.returnType.asTypeNameFromString())
                .apply { if (hasParams) addParameters(m.parameters.map { ParameterSpec.builder(it.name, it.type.asTypeNameFromString()).build() }) }
                .addCode(
                    """
                    val req = RpcRequest(
                        messageId = generateMessageId(),
                        timestamp = Clock.System.now().toEpochMilliseconds(),
                        serviceName = %S,
                        methodId = %S,
                        parameters = listOf(${paramsEncode(m)})
                    )
                    transport.send(req)

                    val resp = withTimeout(callTimeoutMs) {
                        transport.receive().filterIsInstance<RpcResponse>().first { it.messageId == req.messageId }
                    }
                    
                    """.trimIndent(),
                    service.serviceName,
                    m.rpcMethodId,
                ).addStatement("return json.decodeFromString<%L>(resp.result.toString())" , m.returnType)
                .build()
        }
    }

    /** init { ... } block wiring subscriptionCount to start/stop streams for NO-ARG streaming methods */
    private fun initStreamingBlock(service: ServiceInfo): CodeBlock {
        val b = CodeBlock.builder()
        val noArgStreams = service.methods.filter { it.isStreaming && it.parameters.isEmpty() }
        if (noArgStreams.isEmpty()) return b.build()

        b.add("scope.launch(Dispatchers.Default)Â·{\n").indent()
        noArgStreams.forEach { m ->
            val base = methodBase(m.methodName)
            val idVar = "stream${base}Id"
            val backing = "_${m.methodName}"
            val itemType = flowInnerType(m.returnType)

            b.add(
                """
                $backing.subscriptionCount.collect { subCount ->
                    if (subCount > 0) {
                        if ($idVar == null) {
                            val safeStreamId = generateStreamId().also { $idVar = it }
                            val start = StreamStart(
                                messageId = generateMessageId(),
                                timestamp = Clock.System.now().toEpochMilliseconds(),
                                streamId = safeStreamId,
                                serviceName = %S,
                                methodId = %S,
                                parameters = emptyList()
                            )
                            transport.send(start)

                            scope.launch {
                                transport.receive()
                                    .filterIsInstance<StreamData>()
                                    .collect { ev ->
                                        if (ev.streamId == safeStreamId) {
                                            val value = json.decodeFromString<%L>(ev.data.toString())
                                            $backing.emit(value)
                                        }
                                    }
                            }
                        }
                    } else {
                        val oldId = $idVar
                        if (oldId != null) {
                            $idVar = null
                            val stop = StreamEnd(
                                messageId = generateMessageId(),
                                timestamp = Clock.System.now().toEpochMilliseconds(),
                                streamId = oldId
                            )
                            transport.send(stop)
                        }
                    }
                }
                
                """.trimIndent(),
                service.serviceName,
                m.rpcMethodId,
                itemType
            )
        }
        b.unindent().add("}\n")
        return b.build()
    }

    // ----------------------------- small helpers -----------------------------

    private fun defaultJsonFun(): FunSpec =
        FunSpec.builder("defaultJson")
            .returns(ClassName("kotlinx.serialization.json", "Json"))
            .addKdoc("Default Json settings for RPC clients")
            .addCode(
                """
                return Json {
                    ignoreUnknownKeys = true
                    isLenient = true
                    encodeDefaults = true
                    prettyPrint = false
                }
                """.trimIndent()
            )
            .build()

    private fun genMessageIdFn(): FunSpec =
        FunSpec.builder("generateMessageId")
            .addModifiers(KModifier.PRIVATE)
            .returns(String::class)
            .addCode(
                """
                val ts = Clock.System.now().toEpochMilliseconds()
                val rnd = (1000..9999).random()
                return "msg_${'$'}ts${'$'}rnd"
                """.trimIndent()
            )
            .build()

    private fun genStreamIdFn(): FunSpec =
        FunSpec.builder("generateStreamId")
            .addModifiers(KModifier.PRIVATE)
            .returns(String::class)
            .addCode(
                """
                val ts = Clock.System.now().toEpochMilliseconds()
                val rnd = (1000..9999).random()
                return "stream_${'$'}ts${'$'}rnd"
                """.trimIndent()
            )
            .build()

    private fun paramsEncode(m: MethodInfo): String =
        if (m.parameters.isEmpty()) "" else m.parameters.joinToString { "json.parseToJsonElement(json.encodeToString(${it.name}))" }

    private fun methodBase(methodName: String): String =
        methodName.removePrefix("stream").replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }

    private fun flowInnerType(type: String): String =
        when {
            type.startsWith("kotlinx.coroutines.flow.Flow<") -> type.removePrefix("kotlinx.coroutines.flow.Flow<").removeSuffix(">").trim()
            type.startsWith("Flow<") -> type.removePrefix("Flow<").removeSuffix(">").trim()
            else -> type
        }
}

/* ---------------------------- Type helpers ---------------------------- */

private fun String.asTypeNameFromString(): TypeName {
    val isNullable = endsWith("?")
    val core = if (isNullable) dropLast(1) else this

    val lt = core.indexOf('<')
    val typeName: TypeName = if (lt >= 0 && core.endsWith(">")) {
        val base = core.substring(0, lt).trim()
        val argsBlock = core.substring(lt + 1, core.lastIndexOf('>'))
        val args = splitTopLevelCommas(argsBlock).map { it.trim().asTypeNameFromString() }
        mapBaseToClassName(base).parameterizedBy(args)
    } else {
        mapBaseToClassName(core)
    }

    return typeName.copy(nullable = isNullable)
}

private fun mapBaseToClassName(base: String): ClassName {
    if ('.' in base) return ClassName.bestGuess(base)
    return when (base) {
        // stdlib
        "Int","Long","Short","Byte","Float","Double","Boolean","Unit","String" ->
            ClassName("kotlin", base)
        // collections
        "List","Set","Map","MutableList","MutableSet","MutableMap","Collection","Iterable" ->
            ClassName("kotlin.collections", base)
        // Flow
        "Flow" -> ClassName("kotlinx.coroutines.flow", "Flow")
        else -> ClassName.bestGuess(base)
    }
}

// split generic args by commas not inside <...>
private fun splitTopLevelCommas(s: String): List<String> {
    val out = ArrayList<String>()
    val buf = StringBuilder()
    var depth = 0
    for (ch in s) {
        when (ch) {
            '<' -> { depth++; buf.append(ch) }
            '>' -> { if (depth > 0) depth--; buf.append(ch) }
            ',' -> if (depth == 0) { out += buf.toString(); buf.clear() } else buf.append(ch)
            else -> buf.append(ch)
        }
    }
    if (buf.isNotEmpty()) out += buf.toString()
    return out
}