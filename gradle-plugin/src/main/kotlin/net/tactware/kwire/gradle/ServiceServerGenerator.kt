package net.tactware.kwire.gradle

import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeName
import com.squareup.kotlinpoet.TypeSpec

class ServiceServerGenerator {

    data class GenerationServerTarget(
        val packageName: String,
        val superType: ClassName,   // anchor abstract base
        val factoryReturn: ClassName, // usually the service interface
        val serverSimpleName: String,
        val emitFactory: Boolean
    )

    fun generate(service: ServiceInfo): String = generate(service, anchor = null)

    fun generate(service: ServiceInfo, anchor: ServerAnchorInfo?): String {
        val iface = ClassName(service.packageName, service.interfaceName)
        val target = if (anchor != null) {
            GenerationServerTarget(
                packageName = anchor.packageName,
                superType = ClassName(anchor.packageName, anchor.abstractClassName),
                factoryReturn = iface,
                serverSimpleName = "${service.interfaceName}ServerImpl",
                emitFactory = anchor.generateFactory
            )
        } else {
            GenerationServerTarget(
                packageName = service.packageName,
                superType = iface,
                factoryReturn = iface,
                serverSimpleName = "${service.interfaceName}ServerImpl",
                emitFactory = true
            )
        }
        return generateIntoTarget(service, target)
    }

    private fun generateIntoTarget(service: ServiceInfo, target: GenerationServerTarget): String {
        val serverClassName = ClassName(target.packageName, target.serverSimpleName)

        val file = FileSpec.builder(target.packageName, target.serverSimpleName)
            .addFileComment("Generated by KWire RPC Plugin â€” DO NOT EDIT")
            .addImport("net.tactware.kwire.core", "RpcTransport")
            .addImport("net.tactware.kwire.core.messages",
                "RpcRequest","RpcResponse","StreamStart","StreamEnd","StreamData")
            .addImport("kotlinx.coroutines", "CoroutineScope","Dispatchers","SupervisorJob","launch","cancel","Job")
            .addImport("kotlinx.coroutines.flow", "collect","filterIsInstance")
            .addImport("kotlinx.serialization.json", "Json","encodeToString","decodeFromString","parseToJsonElement")
            .addImport("kotlinx.datetime", "Clock")
            .addImport("java.util.concurrent", "ConcurrentHashMap")
            .addType(buildServerClass(service, target, serverClassName))
            .apply { if (target.emitFactory) addFunction(buildFactoryFunction(service, target, serverClassName)) }
            .build()

        return file.toString()
    }

    private fun buildServerClass(
        service: ServiceInfo,
        target: GenerationServerTarget,
        serverClassName: ClassName
    ): TypeSpec {
        val ctor = FunSpec.constructorBuilder()
            .addParameter("transport", ClassName("net.tactware.kwire.core", "RpcTransport"))
            .addParameter("impl", ClassName(service.packageName, service.interfaceName))
            .addParameter(ParameterSpec.builder("json", ClassName("kotlinx.serialization.json", "Json"))
                .defaultValue("defaultJson()").build())
            .addParameter(ParameterSpec.builder("dispatcher", ClassName("kotlinx.coroutines", "CoroutineDispatcher"))
                .defaultValue("Dispatchers.Default").build())
            .build()

        return TypeSpec.classBuilder(serverClassName)
            .addKdoc("Server shim for %L (%L). Wires RpcTransport <-> implementation.", service.interfaceName, service.serviceName)
            .superclass(target.superType)
            .primaryConstructor(ctor)
            .addProperty(prop("transport","net.tactware.kwire.core","RpcTransport","transport"))
            .addProperty(prop("impl", service.packageName, service.interfaceName, "impl"))
            .addProperty(prop("json","kotlinx.serialization.json","Json","json"))
            .addProperty(PropertySpec.builder("scope", ClassName("kotlinx.coroutines","CoroutineScope"))
                .initializer("CoroutineScope(SupervisorJob() + dispatcher)").addModifiers(KModifier.PRIVATE).build())
            .addProperty(PropertySpec.builder("streamJobs",
                ClassName("java.util.concurrent","ConcurrentHashMap")
                    .parameterizedBy(ClassName("kotlin","String"), ClassName("kotlinx.coroutines","Job")))
                .initializer("ConcurrentHashMap()").addModifiers(KModifier.PRIVATE).build())
            .addFunction(startFn(service))
            .addFunction(stopFn())
            .addFunction(handleUnaryFn(service))
            .addFunction(handleStreamStartFn(service))
            .addFunction(handleStreamEndFn())
            .addType(companionJson())
            .build()
    }

    private fun prop(n:String,pkg:String,t:String,init:String)=
        PropertySpec.builder(n, ClassName(pkg,t)).initializer(init).addModifiers(KModifier.PRIVATE).build()

    private fun startFn(service: ServiceInfo) =
        FunSpec.builder("start")
            .addCode(
                """
                scope.launch {
                    transport.receive().collect { msg ->
                        when (msg) {
                            is RpcRequest  -> handleUnary(msg)
                            is StreamStart -> handleStreamStart(msg)
                            is StreamEnd   -> handleStreamEnd(msg)
                            else -> {}
                        }
                    }
                }
                """.trimIndent()
            ).build()

    private fun stopFn() =
        FunSpec.builder("stop")
            .addCode(
                """
                scope.cancel()
                streamJobs.values.forEach { it.cancel() }
                streamJobs.clear()
                """.trimIndent()
            ).build()

    private fun handleUnaryFn(service: ServiceInfo): FunSpec {
        val b = CodeBlock.builder()
        b.add(
            """
            return scope.launch {
                try {
                    val result = when (req.methodId) {
            """.trimIndent()
        ).add("\n")

        service.methods.filter { !it.isStreaming }.forEach { m ->
            b.add("                        %S -> {\n", m.rpcMethodId)
            m.parameters.forEachIndexed { idx, p ->
                b.addStatement("                            val %L: %T = json.decodeFromString(req.parameters[%L].toString())",
                    p.name, p.type.asTypeNameFromString(), idx)
            }
            val args = m.parameters.joinToString { it.name }
            if (m.returnType == "Unit" || m.returnType == "kotlin.Unit") {
                b.addStatement("                            impl.%L(%L)", m.methodName, args)
                b.addStatement("                            kotlinx.serialization.json.JsonNull")
            } else {
                b.addStatement("                            val out: %T = impl.%L(%L)",
                    m.returnType.asTypeNameFromString(), m.methodName, args)
                b.addStatement("                            json.parseToJsonElement(json.encodeToString(out))")
            }
            b.add("                        }\n")
        }

        b.add(
            """
                        else -> json.parseToJsonElement(""" + "\"\"\"{\"error\":\"Unknown methodId: \${req.methodId}\"}\"\"\"" + """)
                    }

                    val resp = RpcResponse(
                        messageId = req.messageId,
                        timestamp = Clock.System.now().toEpochMilliseconds(),
                        result    = result
                    )
                    transport.send(resp)
                } catch (t: Throwable) {
                    val resp = RpcResponse(
                        messageId = req.messageId,
                        timestamp = Clock.System.now().toEpochMilliseconds(),
                        result = json.parseToJsonElement(""" + "\"\"\"{\"error\":\"\${t.message}\"}\"\"\"" + """)
                    )
                    transport.send(resp)
                }
            }
            """.trimIndent()
        )

        return FunSpec.builder("handleUnary")
            .addModifiers(KModifier.PRIVATE)
            .addParameter("req", ClassName("net.tactware.kwire.core.messages","RpcRequest"))
            .returns(ClassName("kotlinx.coroutines","Job"))
            .addCode(b.build())
            .build()
    }

    private fun handleStreamStartFn(service: ServiceInfo): FunSpec {
        val b = CodeBlock.builder()
        b.add(
            """
            if (streamJobs.containsKey(start.streamId)) return
            val job = scope.launch {
                try {
                    when (start.methodId) {
            """.trimIndent()
        ).add("\n")

        service.methods.filter { it.isStreaming }.forEach { m ->
            b.add("                        %S -> {\n", m.rpcMethodId)
            m.parameters.forEachIndexed { idx, p ->
                b.addStatement("                            val %L: %T = json.decodeFromString(start.parameters[%L].toString())",
                    p.name, p.type.asTypeNameFromString(), idx)
            }
            val args = m.parameters.joinToString { it.name }
            b.add(
                """
                            impl.%L(%L).collect { item ->
                                val data = StreamData(
                                    messageId = generateMessageId(),
                                    timestamp = Clock.System.now().toEpochMilliseconds(),
                                    streamId  = start.streamId,
                                    data      = json.parseToJsonElement(json.encodeToString(item))
                                )
                                transport.send(data)
                            }
                """.trimIndent(), m.methodName, args
            )
            b.add("\n                        }\n")
        }

        b.add(
            """
                        else -> {}
                    }
                } finally {
                    streamJobs.remove(start.streamId)
                }
            }
            streamJobs[start.streamId] = job
            """.trimIndent()
        )

        return FunSpec.builder("handleStreamStart")
            .addModifiers(KModifier.PRIVATE)
            .addParameter("start", ClassName("net.tactware.kwire.core.messages","StreamStart"))
            .addCode(b.build())
            .build()
    }

    private fun handleStreamEndFn() =
        FunSpec.builder("handleStreamEnd")
            .addModifiers(KModifier.PRIVATE)
            .addParameter("end", ClassName("net.tactware.kwire.core.messages","StreamEnd"))
            .addCode("streamJobs.remove(end.streamId)?.cancel()\n")
            .build()

    private fun companionJson(): TypeSpec =
        TypeSpec.companionObjectBuilder()
            .addFunction(FunSpec.builder("defaultJson")
                .returns(ClassName("kotlinx.serialization.json","Json"))
                .addCode(
                    """
                    return Json {
                        ignoreUnknownKeys = true
                        isLenient = true
                        encodeDefaults = true
                        prettyPrint = false
                    }
                    """.trimIndent()
                ).build())
            .addFunction(FunSpec.builder("generateMessageId")
                .returns(String::class)
                .addCode(
                    """
                    val ts = Clock.System.now().toEpochMilliseconds()
                    val rnd = (1000..9999).random()
                    return "msg_${'$'}ts${'$'}rnd"
                    """.trimIndent()
                ).build())
            .build()


    /* ===== shared type helpers (same as client) ===== */

    private fun String.asTypeNameFromString(): TypeName {
        val isNullable = endsWith("?")
        val core = if (isNullable) dropLast(1) else this
        val lt = core.indexOf('<')
        val typeName: TypeName = if (lt >= 0 && core.endsWith(">")) {
            val base = core.substring(0, lt).trim()
            val argsBlock = core.substring(lt + 1, core.lastIndexOf('>'))
            val args = splitTopLevelCommas(argsBlock).map { it.trim().asTypeNameFromString() }
            mapBaseToClassName(base).parameterizedBy(args)
        } else {
            mapBaseToClassName(core)
        }
        return typeName.copy(nullable = isNullable)
    }

    private fun mapBaseToClassName(base: String): ClassName {
        if ('.' in base) return ClassName.bestGuess(base)
        return when (base) {
            "Int","Long","Short","Byte","Float","Double","Boolean","Unit","String" ->
                ClassName("kotlin", base)
            "List","Set","Map","MutableList","MutableSet","MutableMap","Collection","Iterable" ->
                ClassName("kotlin.collections", base)
            "Flow" -> ClassName("kotlinx.coroutines.flow", "Flow")
            else -> ClassName.bestGuess(base)
        }
    }

    private fun splitTopLevelCommas(s: String): List<String> {
        val out = ArrayList<String>()
        val buf = StringBuilder()
        var depth = 0
        for (ch in s) {
            when (ch) {
                '<' -> { depth++; buf.append(ch) }
                '>' -> { if (depth > 0) depth--; buf.append(ch) }
                ',' -> if (depth == 0) { out += buf.toString(); buf.clear() } else buf.append(ch)
                else -> buf.append(ch)
            }
        }
        if (buf.isNotEmpty()) out += buf.toString()
        return out
    }

    private fun buildFactoryFunction(
        service: ServiceInfo,
        target: GenerationServerTarget,
        serverClassName: ClassName
    ): FunSpec =
        FunSpec.builder("create${target.serverSimpleName}")
            .returns(serverClassName) // return the concrete server shim
            .addParameter("transport", ClassName("net.tactware.kwire.core", "RpcTransport"))
            .addParameter("impl", ClassName(service.packageName, service.interfaceName))
            .addParameter(
                ParameterSpec.builder(
                    "json",
                    ClassName("kotlinx.serialization.json", "Json").copy(nullable = true)
                ).defaultValue("null").build()
            )
            .addParameter(
                ParameterSpec.builder(
                    "dispatcher",
                    ClassName("kotlinx.coroutines", "CoroutineDispatcher").copy(nullable = true)
                ).defaultValue("null").build()
            )
            .addCode(
                """
            val actualJson = json ?: defaultJson()
            val actualDispatcher = dispatcher ?: Dispatchers.Default
            return %T(transport, impl, actualJson, actualDispatcher)
            """.trimIndent(),
                serverClassName
            )
            .build()

}

